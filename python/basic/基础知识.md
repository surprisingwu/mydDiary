# 基础知识

#### 输入和输出
* `print()`: 输出
* `input()`: 可以进行输入

#### 逻辑运算符
* `and`: 类似于`JS`中的`&&`
* `or`: 类似于`JS`中的`||`
* `not`: 类似于`JS`中的`!`

#### 运算符
* `%`: 取余
* `/`: 除
* `//`: 整除,向下取整
* `*`: 乘
* `**`: 幂, 也可以使用内置方法`pow(num, num)`第二个参数是多少次幂
* `abs(num)`: 绝对值
* `python`中的比较运算符
	* `== != > < >= <=`等,和`JS`不太一样,没有三个等于
* 成员运算符
	* `in`: 在指定序列中找到值返回`true`,否则返回`false`
	* `not in`: 和上面相反
* 身份运算符
	* `is`: 是判断两个标识符是不是引用自一个对象
	* `is not`: 是判断两个标识符 不是引用自一个对象
* 运算的优先级 : 括号, 指数, 乘除加减

#### 字符串
* `\`: 对一些字符进行转义
* `r''`: `r`对引号内的字符不转义(也就是原始字符串)
* '\n': 换行
* `'''abc'''`: `'''`是'\n'的简写
* `str.find(i)`: 查找某一个字符的位置,没有则返回-1
* `str.replace(willReplace, place)`: 对字符串中制定的字符进行替换
* 字符串可以通过索引来取值
* 可以通过加法进行拼接
* 可以通过乘法进行快速复制
* 也可以通过in来判断是否是该字符串的成员
* 也有切片相关的操作,不支持切片部分赋值

```python
  test = 'abcdef'
  test[0]   # 'a'
  test = test + 'gh'   # 'abcdefgh'
  name = 'py'
  name *3  #'pypypy'
  name[:2]   # 'py'
  name[:2] = 'hh' #
```

#### 模块
* 可以通过`import` 引入一个模块
* 如果确定不会从不同模块导入多个同名函数,你可能不想每次调用函数时都指定模块名.可以使用import的变种`from math import sqrt`

#### 字符串

* 设置字符串的格式，这里主要说的是用`%`来进行的格式化操作

```python
format = 'Hello, my name is %s, I have money %.2f'
values = ('wyt', 1244.2112)
format % values  # Hello, my name is wyt, I have money 1244.21
```

#### 通过调用format方法实现

1. 格式化字符串分为:
	*  字段名: 索引或标识符, 指出要设置那个值的格式并使用结果来替换该字段.除指定值外,还可制定值的特定部分,如列表的元素
	* 转换标志: 跟在叹号后面的单个字符.当前支持的字符包括r(表示`repr)、s（表示str）、和a（表示ascii）`。如果制定了转换标志， 将不能使用对象本身的格式化设置机制，而是使用制定的函数将对象转换为字符串，在做进一步的格式设置
	* 格式说明符: 跟在冒号后面的表达式。 格式说明符让我们能够详细的制定最终的格式，包括格式类型、字段宽度和数的精度
2. 替换字段名：
	* 向format方法提供未命名参数,字段中也使用未命名字段.此时,则按照参数的顺序替换未命名字段.字段中也可以使用索引来制定参数的顺序.除此之外,还可以制定参数的名称,这样参数则按照名称进行替换
3. 宽度,精度和千位分隔符
	* 这些都是放在冒号后面的
	* 宽度: 使用正数指定
	* 精度: 也是使用整数指定的,但是需要在它前面加上一个表示小数点的句点
	* 千位分隔符: 可使用都好来指定要使用千位分隔符.同时设置其它格式设置的时候,这个逗号应放在宽度和表示精度的句点之间
4. 符号,对齐和使用0填充
	* 再指定宽度和精度的数字前面,可添加一个标志,这个标志可以是零,加好,减号,或空格,其中0表示使用0来填充数字
	* 要使用左对齐,右对齐和居中,可分别使用<,> ^
	* 还有其它的情况,这里不再叙述
5. 基本转换: 主要包括转换标志(叹号开头)和转换类型(冒号开头)
6. 转换标志主要有三个: `s,r, a`
7. 转换类型:如下表

| 类型 | 含义 |
| :----: | :----: |
|	b | 将正数表示为二进制数 |
|	c | 将整数解读为Ucicode码点 |
|	d | 将正数进行十进制进行处理 |
|	e | 使用科学表示法来表示小数 |
|	f | 将小数表示为定点数 |
|	s | 保持字符串的格式不变,这是默认用于字符串的说明符 |

```python

# 替换字段名
'My name is {},I have money {}'.format('wyt', 123)
'My name is {1},I have money {0}'.format(123, 'wyt')

'My name is {name},I have money {1}'.format(name='wyt', 123)

# 基本转换

print('{pi!s} {pi!r} {pi!a}'.format(pi='π'))  # π 'π' '\u03c0'
'The number is {num:f}.format(num=42)   # 42.000000

# 宽度,精度和千分度
'{num:10}'.format(num=3)     # '          3'
'{name:10}'.format(name='wyt')  # 'wyt         '

'Pi day is {pi:.2f}'.format(pi=pi)  # Pi day is 3.14
'{pi:10.2f}'.format(pi=pi)  # '     3.14'

'I have money {:,}'.format(10000)  # 'I have money 10,000'

# 符号,对齐和用0填充

'{:010.2f}'.format(pi)  # '0000003.14'
print('{0:<10.2f}\n{0:^10.2f}\n{0:>10.2f}').format(pi)

# 3.14
#    3.14
#        3.14

# 可以使用填充字符来扩充对齐说明符,这样将使用指定的字符而不是默认的空格来填充

'{:$^15}'.format(' WIN BIG ')  # '$$$ WIN BIG $$$'
```

* 字符串方法
	* `str.center(num,symbol)`
		* 在字符串俩边添加字符(默认空格),让字符串居中
	* `str.find(str): 在字符串中查找字符串.如果找到则返回第一个字符的索引,否则返回-1`
		* `str.find(str1, startStr, endStr): 还可以制定查找的范围`
		* `str.find(str2, start):`只指定元素查找的起点
	* `str.join(list)`: 用于合并序列的元素(元素必须是字符串)
	* `str.lower()`: 字符串转小写
		* `str.tittle()`: 字符串的首字母大写
		* `str.capwords()`: 这是str模块中的方法, 首字母大写
	* `str.replace(changeStr, str1): 指定字符串都替换为一个字符串,并返回替换的结果`
	* `str.split()`: 与`join()`方法相反,将字符串拆分为序列
	* `str.strp()`: 去除字符串俩头的空白
	* `str.translate()`

```python
'wyt'.center(5) # ' wyt '
'wyt'.center(5, '*')  # '*wyt*'

'I have money,so money'.find('money')  # 7
'I have money,so money'.find('money', 8)  # 16
'I have money,so money'.find('money', 8, 17) # -1

list1 = ['1234']
list2 = ['1', '2', '3', '4']
sep = '+'

sep.join(list1)  # '1+2+3+4'
sep.join(list2)  # '1+2+3+4'

```

#### 编码相关
* `ord(str)`: 返回字符的整数表示
* `chr(str)`: 把编码转换为对应的字符
* `str.encode(格式)`: 解析成所输入编码格式的字节
* `code.decode(格式)`: 字节转换成对应格式的编码
* `len(str)`: 返回字符对应的长度

#### 格式化
* `%s`: 字符串替换
* `%d`: 整数替换
* `%f`: 浮点数替换
* `%x`: 16进制整数替换
* 其中，格式化整数和浮点数还可以指定是否补0和整数与小数的位数

```python
  test = '我的名字是%s,现在手里有$%d,每月的开销占我一年收入的%.2f' 
  print(test %('wyt', 20000, 10.121111)
```

* 另一种格式化字符串的方法是使用字符串的format()方法，它会用传入的参数依次替换字符串内的占位符{0}、{1}……，不过这种方式写起来比%要麻烦得多

```python
  test = '我的名字是{0},现在手里有{1},每月的开销占我一年收入的{2:.2f}%%' 
  print(test.format('wyt', 2000, 11.11111))
```

#### 序列, 列表,元组

> * 常见序列包括字符串(普通字符串和unicode字符串),列表和元组,即成员有序排列,可以通过下标访问  

* 索引
	* 序列(字符串)中的元素都是有序的,拥有自己编号(从0开始),可以通过索引来拿到制定的元素
		* `[index]`
* 加法
	* 俩种相同的序列才可以进行加法操作,这里的相同指的是数据的类型

```python
  [1,2] + ['3', '4']  # [1,2,'3','4']
  
  '12'+'34'    # '1234'
    '123'+[1]   # 报错
```

* 乘法
	* 序列可以通过相乘进行快速复制
* 成员资格
	* 可以通过in 以及not in来判断某一个字符是否是该序列的成员
* 最大值,最小值,长度
	* `最大值: max(list) 最小值:min(list) 长度:len(list)`
* 列表以及列表的方法
	* `list函数,创建列表`
		* `list(序列)`: `list`函数可以把其他序列转化为列表
	* 通过赋值改变列表
	* 删除列表元素,通过`del`来删除列表中的元素
```python
s = 'abc'
list(s)   # ['a', 'b', 'c']
num = [1,2,3,4]
num[0],num[1] = 10 ,100

del num[0]   #  [100, 3, 4]
del num[:2]   # [4]
```

* 列表的方法
	* `list.append(o)`: 从后面添加元素
	* `list.count(value)`: 统计元素出现的个数
	* `list.extend(list1)`: `extend`扩展原有列表,貌似列表的加法也可以扩展列表,实际上只是生成了一个新的列表,被连接的俩个列表均没有改变,extend体现了列表的可变性,接收的参数必须是序列
	* `list.insert(index, o)`: 再制定位置插入某一个元素
	* `list.remove(obj)`: 移除列表中匹配到`obj`的z第一个元素
	* `list.pop()`: 从后面删除元素
	* `list.pop(index)`: 删除制定位置的元素
	* `list[index]`: 返回制定位置的元素
	* `list.sort()`: 对列表进行排序
	* `lsit.reverse()`: 转置列表
```python
list = [123, 'name', 'age']
list.push('sex')  // [123, 'name', 'age', 'sex']
list.insert(1, 'face') // [123, 'face', 'name', 'age', 'sex']
list.pop()     // 'sex'
list.pop(1)    // 'face'
list[1]  // 'name'

list.extend('q')
list.extend(4)  # 报错
```

* `tuple`: 另一种有序列表叫元组：`tuple`。`tuple`和`list`非常类似，但是`tuple`一旦初始化就不能修改
	* 这里的不可更改,指的是一维的情况,若果列表是多维的,则子列表中的元素是可以改变的
	* 只有1个元素的tuple定义时必须加一个逗号,，来消除歧义
```python
list = ('age', 18,[12, 14])
list['age'] = 25  // 报错
list[2][0] = 25


// 元组里面只有一个元素时,要加一个逗号
s = (1,)
```

* `random.choice(sequence)`: 从一个非空序列中随机的选取一个元素

#### 字符串转数字, 不符合的会报错
* `int(str)`: 字符串转整数
* `float(str)`:字符串转浮点数
* `str(str)`: 其他类型转字符串
* `bool(str)`: 其他类型转buer

## 条件,循环及其他语句

#### 打印多个参数

* `print(str1,str2,str3,...,sep=symbol)`: 可以自定义分隔符,相拼接
* `print(str1,str2,...., end='')`: 将结束字符串指定为空字符串,以后就可继续打印到当前行

```python
print('Hello', end='')
print('world!')  # Hello world!
```

#### 赋值魔法

* 序列解包(可迭代对象解包)`x,y = y,x`,将一个(或任何可迭代对象)解包,并得到的值存储到一系列变量中.
	* 可使用`*`来收集多余的值,这样无需确保值和变量的个数相同
	* 赋值语句的右边可以是任何类型的序列,但带星号的变量最终包含的总是一个列表

```python
name = 'Albus, Percial Wulfric, Brian, Dumbledore'
first,*middle,last = name.split()
middle    #[Percial Wulfric, Brian]

# 这种收集方式也可用于函数参数列表中
```

#### 条件和条件语句

* 解释器视为假值的有: `False None 0 "" () [] {}`
* `python`中的任何值都可用作布尔值,而且不需要显示的进行转换

#### 条件语句
```python
// 格式大致为
if condition:
  statement
elif condition:
  statement
else
  statement

// 例子如下  
  height = float(input('请输入你的身高'))
  weight = float(input('请输入你的体重'))
  BMI = weight/(height**2)
  print(BMI)
  if BMI>=32:
    print('过于肥胖')
  elif BMI >= 28:
    print('肥胖')
  elif BMI>=25:
    print('过重')
  elif BMI>= 18.5:
    print('正常')
  else:
    print('过轻') 
```

#### 循环语句
* `for... in循环`

```python
  L = ['Bart', 'Lisa', 'Adam']
for name in L:
  print('hello, %s!' %name)
```

* `while`循环

```python
sum = 0
for i in range(101):
  sum = sum + i
print(sum)
```

* `range(start, end)`:可以生成一个整数序列.包括起始字符,不包括末尾字符

```python
range(5)  // [0,1,2,3,4]
```

* 循环可以通过`break`跳出循环,也可以通过`continue`跳出当前循环
#### 其他的一些语法
	* `exec(str1, scope)`: 该语句将字符串作为代码执行,没有返回值. `scope`为命名空间
	* `eval(str1,scope):` 将字符串当作语句执行,并返回执行 

## 字典(映射)

> 这种数据结构查找比较快, 但是比较占内存.字典中的键必须是固定的,也就要求组成字典的键是基本类型(数字,字符串和元组)  

#### 字典的创建

* 可以使用字面量的形式: `i = {'name': 'wyt', age: 18}`
* 通过函数`dict()`:
	* 传入键值序列: `d = dict([('name','wyt'),('age',18)])`
	* 传入关键字参数: `d = dict(name='wyt', age=18)`

#### 字典的基本操作

> 很多方法类似序列,但是有不同的地方.列表不可以给不存在的项赋值,但是字典可以  

* `len(dict)` :返回字典 `d`包含的(键值)项数
* `d[k]`: 返回与`k`相关联的值
* d[k] = v: 将 `v`关联到键 `k`
* del d[k]: 删除键为`k`的项
* k in d: 检查字典`d`是否包含键为`k`的项

#### 将字符串格式设置功能用于字典

* 主要是通过`format_map`来实现的

```python
phoneBook = {'name': 'wyt', 'age': 19}
'I know this {name}'.format_map(phoneBook)

```
#### 字典的方法

* `dict.clear()`: 清空字典
* `dict.copy()`: 对字典进行浅复制,但是如果字典的值是复杂类型时会带来一些麻烦.深复制可以使用`deepcopy()`
* `dict.fromkeys(seq[,val])`:创建一个新字典，以序列 `seq`中元素做字典的键，`val` 为字典所有键对应的初始值.不传`val`的话值为`None`
* `dict.get(key,default = None)`: 返回指定键的值,如果值不在字典中则返回默认值.(直接访问字典中不存在的值,会报错.因此可以用这个方法去访问)
* `dict.items()`: 以列表的形式返回可遍历的(键值)元组数组
* `dict.keys()`: 以列表的形式返回一个字典所有的键
* `dict.values()`:以列表的形式返回一个字典所有的值
* `dict.pop(key[,default])`: 删除字典给定键 `key` 所对应的值，返回值为被删除的值。`key`值必须给出。 否则，返回`default`值
* `dict.popitem()`:随机返回并删除字典中的一对键和值
* `dict.setdefault(key,default=None)`: 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default
* `dict1.update(dict2)` : 把字典dict2的键/值对更新到dict里

```python
d = {
  "name": "wyt",
  "age": 18
}
d['sex'] = 1

'age' in d  # true
d.get('name','-1')  #'wyt'
d.pop('name')
d.get('naem', -1 )  # -1
```

#### set
* 和`dict`类似,但不存储`value`,对于相同的`key`,`set`会自动过滤掉里面相同的元素,类似于`JS中的Set`
* 要创建一个`set`,需要提供一个`list`作为输入集合
	* `s = set([1, 2, 3])`  # {1, 2, 3}
* `s.add(key)`: 添加元素到set中,可以重复添加,但不会有效果
* `s.remove(key)`: 可以删除元素
* `set`可以看成数学意义上的无序和无重复元素的集合,因此,俩个`set`可以做数学意义上的交集和并集

```python

s1 = set([1, 2, 3])
s2 = set([2, 3, 4])

s1&s2   # {2, 3}
s1|s2   # {1, 2, 3, 4}
```

#### 函数

* 定义函数通过关键字`def`来定义

```python
def check_score(x):
  #  print(x)
  if x >= 90:
    return "A"
  elif x >= 80:
    return 'B'
  elif x > 60:
    return 'C'
  else:
    return 'D'

print(check_score(int(input('请输入您的成绩'))) )  
```

* 函数除了接受前面的位置参数外,还可以设置默认参数,但是默认参数要放在必选参数的后面.类似于`JS`的`ec6`语法,默认参数必须指向不变对象(否则每次调用函数的时候,默认参数都会改变),也即是字符串和数字,`bool或者None`

```python
# pow方法的封装
def power(x, n=2):
    s = 1
    while n > 0:
        n = n - 1
        s = s * x
    return s
```

* 函数里面也可以传入不定参数,这里所谓的可变,是指参数的个数可以改变,不知道要传入多少个参数时

```python
def calc(*numbers):
    sum = 0
    for n in numbers:
        sum = sum + n * n
    return sum
#调用的是以后可以传数字, 也可以通过符号*传入list或者tuple

nums = [1, 2, 3]
calc(*nums)
```

* 关键字参数,可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict

```python
def person(name, age, **kw):
    print('name:', name, 'age:', age, 'other:', kw)

person('wyt',18, sex=1) # name: wyt age: 18 {'sex':1}  
# 对于本身是一个dict时,再调用时可以简写 **类似于js中的展开运算符
 extra = {'city': 'Beijing', 'job': 'Engineer'}
person('Jack', 24, **extra) # name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}
```

* 命名关键字参数: 调用时,输入什么参数以及参数的类型是未知的,有可能会输入一些我们不想要的参数,我们可以限制只接收我们限制的参数,和关键字参数  `kw`不同，命名关键字参数需要一个特殊分隔符**，**后面的参数被视为命名关键字参数。但是传入其他我们不想要的参数时,会报错
	* 如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了
```python
def person(name, age, *, city, job):
    print(name, age, city, job)
    
person('wyt',18, city="beijing", job='enginner',sex=1)   # wyt 18 beijing enginner   

# 对于命名关键字参数前面有可变参数时,*可以省略. 默认可变参数后面的都是命名关键字参数
def person(name, age, *args, city, job):
  print(name, age, args, city, job)

list = ['like', 'money']

person('wyt', 18, *list, city='beijing', job='enginner') # wyt 18 ('like', 'money') beijing enginner

# 命名关键字参数也可以设置一些默认值
def person(name, age, *, city="beijing", job):
  print(name,age,city,job)

person('wyt', 18, job='enginner')   #  wyt 18 beijing enginner

```

* 在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。

```python
def f1(a, b, c=0, *args, **kw):
    print('a =', a, 'b =', b, 'c =', c, 'args =', args, 'kw =', kw)

def f2(a, b, c=0, *, d, **kw):
    print('a =', a, 'b =', b, 'c =', c, 'd =', d, 'kw =', kw)  


args = (1, 2, 3, 4)
kw = {'d': 99, 'x': '#'}
f1(*args, **kw)  # a = 1 b = 2 c = 3 args = (4,) kw = {'d': 99, 'x': '#'}
args = (1, 2, 3)
kw = {'d': 88, 'x': '#'}
f2(*args, **kw)  # a = 1 b = 2 c = 3 d = 88 kw = {'x': '#'}

def f3(a, b ,c, *args):
  print(a, b, c, args)
args = ('name', 'age', 'list', 'sex', 'like')
f3(*args) # name age list ('sex', 'like')

# 一道联系题

def product(x, y = 1, *args):
    ret = x * y
    n = len(args)
    while n > 0:
      n = n - 1
      ret = ret * args[n]
    return ret    
print('product(5) =', product(5))
print('product(5, 6) =', product(5, 6))
print('product(5, 6, 7) =', product(5, 6, 7))
print('product(5, 6, 7, 9) =', product(5, 6, 7, 9))
if product(5) != 5:
    print('测试失败!')
elif product(5, 6) != 30:
    print('测试失败!')
elif product(5, 6, 7) != 210:
    print('测试失败!')
elif product(5, 6, 7, 9) != 1890:
    print('测试失败!')
else:
    try:
        product()
        print('测试失败!')
    except TypeError:
        print('测试成功!')
```

* `return value1, value2,...`: `return`指定函数的返回值,没有的话则是`None`,也可以返回多个值.返回的多值其实是一个`tuple`, 可以通过变量来接收

```python

def move(x, y, step, angle=0):
    nx = x + step * math.cos(angle)
    ny = y - step * math.sin(angle)
    return nx, ny
x, y = move(100, 100, 60, math.pi / 6)    
```
* 空函数

```python
def nop():
    pass # pass起到占位符的作用(现在还不知道怎么写)
```

* 递归函数: 再函数内部调用自身本身,这个函数就是递归函数

```python
def fact(n):
    if n==1:
        return 1
    return n * fact(n - 1)
```
* 使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出
* 尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。
```python
def fact(n):
  return fact_iter(n, 1)

def fact_iter(num, product):
  if num == 1:
      return product
  return fact_iter(num - 1, num * product)
  
# 请编写move(n, a, b,c)函数，它接收参数n，表示3个柱子A、B、C中第1个柱子A的盘子数量，然后打印出把所有子从A借助B移动到C的方法  

def move(n, a, b, c):
  if n == 1:
    print(a, '-->', c)
  else:
    move(n-1, a, c, b) # n-1上面的盘子移动到b上
    move(1, a, b, c)   # 第n个盘子移动到c上
    move(n-1, b, a, c) # b上的n-1个盘子移动到c上
move(3, 'A', 'B', 'C') 
```

* `globals()`: 返回一个包含全局变量的字典
* `locals()`: 返回一个包含局部变量的子典 
```python
	count = 0
	def test():
		global count
		count += 1
	test()
	count   # 1
```

#### 高级特性

* 切片: 是针对于`list和tuple`进行截取的操作
	* `list[start: end]`: 从索引`start`开始取,直到索引`end`为止,但不包括终止值.如果第一个索引是`0`还可以省略,需注意的是,`start和end`可以是负值,并且倒数第一个元素的索引是-1
	* `list[start:end:step]`: 还可以穿第三个参数,表示间距
	* `list[::step]`: 表示对所有值,每`step`,取一个值
	* `list[:]`: 对于原`list`进行复制
	* `列表分片赋值`: 可以对序列进行增删
		* `list[len(list):] = list1`: 再序列的末尾添加
		* `list[index:index] = list1`: 从序列指定的位置进行添加
		* `list[start:end] = list1`: 对序列的一些元素进行替换
		* `list[start:end] = '' or list[start:end] = []`: 删除序列中的一些元素
```python
  L = ['Michael', 'Sarah', 'Tracy', 'Bob', 'Jack']
  
  L[0:2]  # ['Michael', 'Sarah']
  L[:2]   # ['Michael', 'Sarah']
  L[1:2]  # ['Sarah']
  L[-1]   # ['Jack']
  L[-2:]  # ['Bob', 'Jack']
  L[-2:-1]   # ['Bob']
  
  L = [1,2,3,4,5,6,7,8,9,10]
  L[:10:2]  # [0, 2, 4, 6, 8]
  L[::5]   # [1, 6]
  L[:]      # [1,2,3,4,5,6,7,8,9,10]
  
  # 利用切片操作，实现一个trim()函数，去除字符串首尾的空格
  
  # 利用递归实现
  def trim (str):
    if str[-1:] == ' ':
      return trim(str[:-1])
    elif str[:1] == ' ':
      return trim(str[1:])        
    else:
      return str
# 利用循环实现      
def trim(s):
    while s[:1] == ' ':
        s = s[1:]
    while s[-1:] == ' ':
        s = s[:-2]
    return s
```

* 可迭代
	* 迭代是通过`for in`循环来实现的, 对于`dict`遍历默认遍历的是`key`,如果要迭代`value`可以用`for value in d.values()`,如果要同时迭代key和value,可以用`for k,v in d.items()`,基本上只要是可跌带对象都可以进行遍历.
		* 可以通过`collections`模块的`Iterable`类型判断
```python
  d = {"name": 'wyt', 'age': 18}
  
  for value in d.values():
    print(value)
  # wyt 18
  
  for k,v in d.items():
    print(k,v)
  # name wyt age 18
  
    from collections import Iterable
    isinstance('abc', Iterable) # str是否可迭代
```

* 如果遍历`list`想和`dict`一样,可以使用`python`内置的`enumerate`函数可以把一个`list`变成索引-元素对,这样就可以在`for`循环中同时迭代索引和元素本身

```python
for i, value in enumerate(['A', 'B', 'C']):
     print(i, value)

# 0 A 1 B 2 C
```

* 列表生成式
	* 要生成一个数字列表,[1,2,3,4,5,6],则可以使用`list(range(1, 7))`
	* 如果要生成[1/1, 2/2, 3/3, 4/4, 5/5, 6/6], 则可以`[x*x for x in range(1, 7)]`, `for`循环后面还可以跟`if`判断`[x*x for x in range(1,7) if x%2 == 0]`
	* 还可以使用两层循环，可以生成全排列, 三层以上的循环就比较少了
```python
[m + n for m in 'ABC' for n in 'XYZ']     # ['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ']


import os # 导入os模块，模块的概念后面讲到
[d for d in os.listdir('.')] # os.listdir可以列出文件和目录
['.emacs.d', '.ssh', '.Trash', 'Adlm', 'Applications', 'Desktop', 'Documents', 'Downloads', 'Library', 'Movies', 'Music', 'Pictures', 'Public', 'VirtualBox VMs', 'Workspace', 'XCode']

# for循环其实可以同时使用两个甚至多个变量，比如dict的items()可以同时迭代key和value：
d = {'x': 'A', 'y': 'B', 'z': 'C' }
for k, v in d.items():
     print(k, '=', v)
# y = B
# x = A
# z = C

# 因此，列表生成式也可以使用两个变量来生成list：
d = {'x': 'A', 'y': 'B', 'z': 'C' }
[k + '=' + v for k, v in d.items()]
# ['y=B', 'x=A', 'z=C']
```

* 生成器:
	* 能够用列表生成式,生成的,只需要把`[]改成()`,即可
```python
   L = (x * x for x in range(10))
   
   # 我们可以通过 next(L),拿到每一次的返回值
   next(L)  # 0
   next(L)  # 1
   
   # 对于生成器我们可以通过`for`来遍历
   
   g = (x * x for x in range(10))
   for n in g:
     print(n)
```

* 如果一个函数定义中包含`yield`关键字，那么这个函数就不再是一个普通函数，而是一个`generator`
```python
  # 斐波拉契数列, 和js中的生成器函数比较像
  def fib(max):
    n, a, b = 0, 0, 1  # 赋值
    while n < max:
        yield b
        a, b = b, a + b  # 赋值
        n = n + 1
    return 'done'
  # 杨辉三角也可以用生成器函数来实现  
          1
         / \
        1   1
       / \ / \
      1   2   1
     / \ / \ / \
    1   3   3   1
   / \ / \ / \ / \
  1   4   6   4   1
 / \ / \ / \ / \ / \
1   5   10  10  5   1  

def triangles():
    ret = [1]
    while True:
        yield ret    
        if len(ret) == 1:
            ret = ret + [1]
        else:
            ret = [1]+[ret[i]+ret[i+1] for i in range(len(ret) - 1)]+[1]
    return 'done'
    
```

* 迭代器
	* 可以通过`for`循环遍历的有集合数据类型: `list, tuple,dict,set,str`.还有就是`generator和generator function`,能够被`for`循环遍历的对象统称为可迭代对象: `Iterable`

```python
# 可以使用isinstance 判断一个对象是否是 Iterable对象

from collections import Iterable
isinstance([], Iterable)
# True
isinstance({}, Iterable)
# True
isinstance('abc', Iterable)
# True
isinstance((x for x in range(10)), Iterable)
# True
isinstance(100, Iterable)
# False
```

* 而生成器不仅可以被for循环遍历还可以被`next()`函数不断的调用并返回下一个值,知道最后抛出`StopIteration`错误无法继续返回下一个值.可以被`next()`函数调用并不断返回下一个值得对象成为迭代器: `Iterator`

```python
from collections import Iterable
isinstance([], Iterable)
# True
isinstance({}, Iterable)
# True
isinstance('abc', Iterable)
# True
isinstance((x for x in range(10)), Iterable)
# True
isinstance(100, Iterable)
# False
```

* 而生成器不但可以作用于for循环，还可以被next()函数不断调用并返回下一个值，直到最后抛出StopIteration错误表示无法继续返回下一个值了。可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。 可以使用isinstance()判断一个对象是否是Iterator对象：

```python
from collections import Iterator
isinstance((x for x in range(10)), Iterator)
# True
isinstance([], Iterator)
# False
isinstance({}, Iterator)
# False
isinstance('abc', Iterator)
# False
```

* 可以通过内置函数`iter(Iterable)`把可迭代对象转化为迭代器

```python
isinstance(iter([]), Iterator)
# True
isinstance(iter('abc'), Iterator)
# True
```

#### 函数式编程
函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。
函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！
Python对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言。

* 
高阶函数
> 既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。  

* 函数可以做为值进行传递,也可以像变量一样重新赋值,也可以作为函数的参数,和`JS`中的一等公民函数比较相似,JS中的高阶函数是接收一个函数,然后返回一个函数
* `map和reduce`
	* `map(fn, iterable)`函数接收两个参数，一个是函数，一个是`Iterable`，`map`将传入的函数依次作用到序列的每个元素，并把结果作为新的`Iterator`.返回`Iterator`是惰性序列，因此通过`list()`函数让它把整个序列都计算出来并返回一个`list`。
```python
    def f(x):
      return x * x

    r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])

    print(list(r)) # [1, 4, 9, 16, 25, 36, 49, 64, 81]
```

*  `reduce(fn, iterable)`: 这个函数必须接收两个参数，`reduce`把结果继续和序列的下一个元素做累积计算,类似于`JS`的累加器

```python
    from functools import reduce
    def add(x, y):
      return x + y
    reduce(add, [1, 3, 5, 7, 9])
    # 25
    
    # 把字符串'123.456'转换成浮点数123.456
    from functools import reduce
    def str2float(s):
      i = s.find('.')
      j = len(s)- i -1
      def fn(x, y):
        return x * 10 + y
      return reduce(fn, map(int, s.replace('.',''))) / 10 ** j
```

* `filter(fn, iterable)`: 对于可迭代对象每一个传入函数,跟句返回值`true or false`决定保留还是丢弃该元素

```python
  # 删掉偶数保留奇数
  def is_odd(n):
    return n % 2 == 1

  list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))
  
  # 回数是指从左向右读和从右向左读都是一样的数，例如12321，909。请利用filter()筛选出回数
  
  def is_palindrome(n):
    m = str(n)
    i = len(m)
    def fn(g):
      ret = True
      h = i // 2
      while h > 0:
        h = h -1
        if g[h] != g[i -1]:
          ret = False
          break
      return ret
    return n < 10 or fn(m) 
    
output = filter(is_palindrome, range(1, 1000))
print('1~100:', list(output))

```

* `sorted(list, key= customFn , reverse = bool)`: `sorted`可以对`list`进行排序,可以传入第二个参数进行自定义排序,以及第三个参数控制是否翻转`list`,默认的是`false`
* 这里要注意的是`filter,map,reduce`返回的都是`Iterator`,可以通过`list()`来转换成一个`list`
```python
sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower)
# ['about', 'bob', 'Credit', 'Zoo']
sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True)
# ['Zoo', 'Credit', 'bob', 'about']

# 下面的元组组成的list分别按照名字和成绩的高低进行排序
L = [('Bob', 75), ('Adam', 92), ('Bart', 66), ('Lisa', 88)]

# 按照名字进行排序
def by_name(t):
    return t[0].lower()

# 按照成绩的高低
def by_score(t):
    return t[1]
```

* 返回函数: 高阶函数除了可以接受函数作为参数外,还可以返回一个函数, 函数内部的函数可以访问到函数内部的局部变量,也即是行成了一个闭包
	* 返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。如果执行要用的话,可以再创建一个函数,保存之前的变量

```python

def count():
    fs = []
    for i in range(1, 4):
        fs.append(lambda x=i: x*x ) # f(i)立刻被执行，因此i的当前值被传入f()
    return fs
f1, f2, f3 = count()
print(f1(), f2(), f3())  # 1 4 9

# 利用闭包返回一个计数器函数，每次调用它返回递增整数, 实现的原理和`JS`比较像, 只需要外层函数变量放在堆中即可
# nonlocal 关键字用来在函数或其他作用域中使用外层(非全局)变量。

def createCounter():
    n = [0]
    def counter():
      n[0] = n[0] + 1
      return n[0]
    return counter

def counter():
    n=0
    def f():
        nonlocal n # nonlocal关键字声明每次调用时修改外层的变量
        n+=1
        return n
    return f
```

* 匿名函数: 可以使用`lambda`关键字来声明匿名函数,冒号前面的表示函数的参数.匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数

```python

f = lambda x,y: x*y
f(1,2) # 2

# 也可以作为函数的返回值返回

def build (x,y):
  return lambda x,y : x+y
```

* 装饰器: 这种在代码运行期间动态增加功能的方式,称之为装饰器(`deccorator`), (本质是对原函数进行包裹, 再不改变原函数的基础上增加功能),再使用装饰者模式时,还需要使用`python`的`@`语法,把`decorator`的定义处
	* 因为返回的那个`wrapper()`函数名字就是`wrapper`，所以，需要把原始函数的`__name__`等属性复制到`wrapper()`函数中，否则，有些依赖函数签名的代码执行就会出错。
```python
import functools
def log(func):
    @functools.wraps(func)
    def wrapper(*args, **kw):
        print('call %s():' % func.__name__)
        return func(*args, **kw)
    return wrapper
@log
def now():
    print('2015-3-25')
    
now()  # call now()  2015-3-25

# 装饰器也可以接受参数,只不过要多一层函数嵌套
import functools
def log(text):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kw):
            print('%s %s():' % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator
    
@log('execute')
def now():
    print('2015-3-25')
    
now()
# execute now():
# 2015-3-25    
```

* 偏函数: 把一个函数的某些参数固定住(也就是默认值).返回一个新的函数,使函数的调用更加简单
	* `functools.partial(fn, defaultKey = defaultValue)`
```python
int2 = functools.partial(int, base=2)
int2('1000000')
# 64

# 手动实现partial
def partial(fn, **x):
  def wrapper(*arg, **kw):
    print(x)
    return fn(*arg, **x, **kw)
  return wrapper
```

#### 模块

> 每一个`.py`文件就是一个模块,模块的命名不能和系统内置的模块名冲突.再有模块的名字相同时,只要顶层的包名不与别人冲突,那所有模块都不会与别人冲突.注意每一个包名下面都会有一个`_init_.py`的文件,这个文件是必须存在的,否则这个目录会当做普通的目录。自己创建模块时要注意命名,不能和`Python`自带的模块名称冲突.最好先检查系统是否已存在该模块,检查方法是在`Python`交互环境中执行`import xxx`,若成功则说明系统存在该模块  

```python
mycompany
 ├─ web
 │  ├─ __init__.py
 │  ├─ utils.py
 │  └─ www.py
 ├─ __init__.py
 ├─ abc.py
 └─ xyz.py
 
文件www.py的模块名就是mycompany.web.www，两个文件utils.py的模块名分别是mycompany.utils和mycompany.web.utils。
```

* 使用模块: 可以直接通过`import fileName`把这个模块引入进来,然后通过`fileName.variable`进行使用,带下划线的函数,变量默认为是私有变量,外部不应该访问, 基本和`js`比较像,没有显示的限制私有和公有变量

#### 面相对象编程
简称—`OOP`,是一种设计思想.把对象作为程序的基本单元,一个对象包含了数据和操作数据的函数
面相过程的程序设计把计算机视为一系列命令的集合,即一组函数的执行顺序.为了简化程序的设计,面相过程把函数继续切分为子函数,即把大块函数切割小块函数来降低系统的复杂度
面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递
面相对象的设计思想是抽象出`Class`,根据`Class`创建`instance`

* 类和实例
	* `class`后面紧接着是类名,类名通常首字母大写,紧接着是`(object)`,表示该类是从哪个类继承下来的,如果没有合适的继承类.就使用`object`,这是所有类最终都会继承的类
	* 可以通过类中的`__init__`方法来初始化实例,该方法的第一个参数是`self`,指向实例本身,后面的参数是调用类时传入的参数. 但是如果类的方法要使用`self`时,页需要传进去. 调用的时候直接传需要的数据就行. 并且在类的方法中可以直接访问初始化的数据
```python
class Student(object):
    def __init__(self, name, score):
        self.name = name
        self.score = score

    def get_grade(self):
        if self.score >= 90:
            return 'A'
        elif self.score >= 60:
            return 'B'
        else:
            return 'C'
            
wyt = Student('wyt','100')

wyt.get_grade()
```

* 访问限制
	* 在`class`内部,可以有属性和方法,而外部代码可以通过直接调用实例变量的方法来操作数据,这样就隐藏了内部的复杂逻辑
	* 如果让内部属性不被外部访问,可以把属性的名称前加俩个下划线`__`,这样这个变量就变成一个私有变量,只有内部可以访问,外部不能访问.其实系统对双下划线的变量做了处理(修改了变量的名称,如果执意访问的话,仍可以访问)
* 继承和多态
	* 前面我们声明一个类的时候,传入的参数时一个`object`,可以传入其他的类,这样就可以继承该类的方法
	* 继承: 创建类的时候的, 引入我们要继承的对象即可,这样子类就有了父类的方法和属性
	* 多态:  所谓的多态,个人理解为对不同类型的对象使用相同的操作,都能够顺利执行,并呈现多种形态
		* 多态是面向对象的重要特性,简单点说:“一个接口，多种实现”，就是同一种事物表现出的多种形态。
		* 编程其实就是一个将具体世界进行抽象化的过程，多态就是抽象化的一种体现，把一系列具体事物的共同点抽象出来, 再通过这个抽象的事物, 与不同的具体事物进行对话。
		* 对不同类的对象发出相同的消息将会有不同的行为
	* 鸭子类型: 动态语言才有鸭子类型,一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子.
* `issubclass(childclass,superclass):判断一个类是否是另一个类的子类`
* `isinstance(instance, superclass)`: 判断 一个对象是否是=一个类的实例
* `childclass.__bases__`: 一个类可以通过`__bases__`访问到它的基类
* `obj.__class__`: 可以判断一个对象属于哪个类 

```python
class Animal(object):
  def run(self):
    print('animal is running')

class Dog(Animal):
  def run(self):
    print('dog is running')

class Cat(Animal):
  def run(self):
    print('cat is running')


def animal_run(animal):
  print(animal)
  animal.run()

a = Animal()
b = Dog()
c = Cat()  

animal_run(a)
animal_run(b)
animal_run(c)

# animal is running
# dog is running
# cat is running
```

* 获取对象信息
	* 使用`type()`: 可以判断一个数据的类型
	* 使用`isinstance(obj, class|(class1, class2,...))`: 判断一个对象是否是某一种类型或者某一些类型的一种
	* 使用`dir()`: 获取一个对象的所有属性和方法,他返回一个包含字符串的`list`,可以配合下面的一些方法使用
		* `hasattr(obj, property)`: 判断一个对象是否有某个属性
	* `getattr(obj,property,defaultval)`: 尝试从一个对象后去某个属性,不存在则返回默认值
	* `setattr(obj,property,defaultval)`: 设置对象的属性
	* `obj.__dict__`: 可以检查对象的属性,但是该对象的父类中设置`__slots__`的话会报错
```python

a = 123
b = '123'
c = None
d = True
def f():
  pass
e = [1,2,3]
g = (1,2,3)
h = {
  '1': 2
} 
# 基本类型
print(type(a) == int)
print(type(b) == str)
print(type(d) == bool)

# 复杂类型
import types 
print(type(c) == types.NoneType)
print(type(f) == types.FunctionType)
print(type(e) == types.ListType)
print(type(g) == types.TupleType)
print(type(h) == types.DictionaryType)

class Animal(object):
  def run(self):
    print('animal is running')

class Dog(Animal):
  def run(self):
    print('dog is running')

a = Animal()
b = Dog()

print(isinstance(b, Dog))
print(isinstance(b, Animal))

obj = {'x': 9}
hasattr(obj, 'x') # 有属性'x'吗？
# True
obj.x # 9
hasattr(obj, 'y') # 有属性'y'吗？
# False
setattr(obj, 'y', 19) # 设置一个属性'y'
hasattr(obj, 'y') # 有属性'y'吗？
# True
getattr(obj, 'y') # 获取属性'y'
```

* 实例属性和类属性: 实例可以访问到类的属性,实例中定义同名的属性时,会覆盖类中的属性

```python
class Student(object):
    name = 'Student'
 s = Student() # 创建实例s
 print(s.name) # 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性
# Student
print(Student.name) # 打印类的name属性
# Student
s.name = 'Michael' # 给实例绑定name属性
print(s.name) # 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性
# Michael
print(Student.name) # 但是类属性并未消失，用Student.name仍然可以访问
# Student
 del s.name # 如果删除实例的name属性
 print(s.name) # 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了
# Student
```

#### 面相对象高级编程
* 可以使用`__slots__ = (attr1, attr2...)`来限制实例中能添加的属性
* 可以动态的给类和实例添加属性和方法

```python
class Student(object):
    __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称
s = Student() # 创建新的实例
s.name = 'Michael' # 绑定属性'name'
s.age = 25 # 绑定属性'age'
s.score = 99 # 绑定属性'score'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'Student' object has no attribute 'score'
```

* `@property`装饰器把一个方法当做编程属性调用(如果只定义`getter`不定义`setter`,则该属性是只读)

```python
class Student(object):

    @property
    def score(self):
        return self._score

    @score.setter
    def score(self, value):
        if not isinstance(value, int):
            raise ValueError('score must be an integer!')
        if value < 0 or value > 100:
            raise ValueError('score must between 0 ~ 100!')
        self._score = value
		@score.deleter
		def score(self):
			del self._score 
			
```

* 多重继承
	* 书写类的时候,可以继承多个类,这样一个子类同时获得多个父类的功能
	* `MixIn`: 再需要继承多个类的时候,可以不用每个都引进来,可以写一个`mixIn`,把需要的类再`mixIn`里面引进来
	* 多重继承时,超类传入顺序很重要,如果多个超类有相同的方法,位置靠前的超类会覆盖后面超类的顺序
```python

class People(object):
  def getName(self):
    print('My name is people')

class Run(object):
  def run(self):
    print('start running')

class Drink(object):
  def drink(self):
    print('start drink')

class RunAndDrinkMixIn(Run, Drink):
  pass

class Female(People, RunAndDrinkMixIn):
  def getName(self):
    print('My name is female')  
class Male(People, RunAndDrinkMixIn):
  def getName(self):
    print('My name is male')
class Test(Female, Male):
  pass
print(Test.__mro__)  
test = Test()
test.getName()

```

* 定制类: 所谓的定制类就是改写从`object`继承的方法,达到定制类的目的
	* `__str__`: 返回用户看到的字符串
	* `__repr__`: 返回程序开发者看到的字符串(原始字符串)
	* `__iter__`: 把迭代对象转化为迭代器的方法
	* `__getitem__`: 通过__iter__方法转化的类虽然能作用于for循环,但是却不能完全当做list来使用,比如通过索引取元素.与该方法对应的还有`__setitem__和__delitem__`
	* `__getattr__`:这个方法是在没有获取到累的属性的时候,会调用这个方法.这样的话,我们可以自己定义错误的信息
	* `__call__`: 可以修改类被调用时,返回的结果
	* `callable(obj)`: 可以判断一个对象是否是可调用对象(是否是一个方法)

```python

# 通过改写__iter__方法,实现迭代器的特性
class Fib(object):
    def __init__(self):
        self.a, self.b = 0, 1 # 初始化两个计数器a，b

    def __iter__(self):
        return self # 实例本身就是迭代对象，故返回自己

    def __next__(self):
        self.a, self.b = self.b, self.a + self.b # 计算下一个值
        if self.a > 100: # 退出循环的条件
            raise StopIteration()
        return self.a # 返回下一个值
    def __getitem__(self, n):  # 支持传入切片
        if isinstance(n, int): # n是索引
            a, b = 1, 1
            for x in range(n):
                a, b = b, a + b
            return a
        if isinstance(n, slice): # n是切片
            start = n.start
            stop = n.stop
            if start is None:
                start = 0
            a, b = 1, 1
            L = []
            for x in range(stop):
                if x >= start:
                    L.append(a)
                a, b = b, a + b
            return L   

for i in Fib():
  print(i)
  
  # 
  class Chain(object):
    def __init__(self, path=''):
        self._path = path
    def __getattr__(self, path):
        return Chain('%s/%s' % (self._path, path))
    def __str__(self):
        return self._path
    def __call__(self, path=''):
        return Chain('%s/%s' % (self._path, path))
    __repr__ = __str__
    
  print(Chain().status.users('michael').repos)    # /status/uders/michael/repos  
```

* 使用枚举类: `_enum = Enum(name,(val1,val2...))` 创建一个可枚举类,使用`_enum.val1`来引用一个常量,`value`属性是自动赋给成员的`int`常量,默认从1开始计数
	* 如果需要更精确地控制枚举类型,可以从`Enum`派生自定义类
	* 既可以用成员名称引用枚举常量，又可以直接根据value的值获得枚举常量。

```python
from enum import Enum

Month = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))
for name, member in Month.__members__.items():
    print(name, '=>', member, ',', member.value)
    
    
from enum import Enum, unique

@unique  # 检查没有重复值的装饰器
class Weekday(Enum):
    Sun = 0 # Sun的value被设定为0
    Mon = 1
    Tue = 2
    Wed = 3
    Thu = 4
    Fri = 5
    Sat = 6  

day1 = Weekday.Mon
print(day1)
# Weekday.Mon
print(Weekday.Tue)
# Weekday.Tue
print(Weekday['Tue'])
# Weekday.Tue
print(Weekday.Tue.value)
# 2
print(day1 == Weekday.Mon)
# True
print(day1 == Weekday.Tue)
# False    
    
```

* 使用元类
	* `type(classname, parentclasses, functionlist)`: 可以返回一个对象的类型,也可以创建新的类型.接受三个参数
		* `class`名称
		* 继承的类集合.注意`python`支持多重继承,如果只有一个类,别忘了`touple`的单元素写法
		* `class`的方法名称和函数绑定
	* `metaclass`: 元类. 允许创建或者修改类(也可以认为创建出来的类时元类的实例).默认的元类的类名都是`Metaclass`结尾
		* `__new__()`方法接收到的参数依次是：

			* 当前准备创建的类的对象；

			* 类的名字；

			* 类继承的父类集合；

			* 类的方法集合。
```python
def fn(self, name='world'): # 先定义函数
     print('Hello, %s.' % name)

 Hello = type('Hello', (object,), dict(hello=fn)) # 创建Hello class
 h = Hello()
h.hello()
# Hello, world.
 print(type(Hello))
# <class 'type'>
 print(type(h))
# <class '__main__.Hello'>

# 使用元类的简单demo
def __new__(cls, name, bases, attrs):
   attrs['add'] = lambda self, value: self.append(value)
   return type.__new__(cls, name, bases, attrs)

class ListAdd(list, metaclass=ListMetaclass):
  pass        

l = ListAdd()
l.add(1)

print(l) # [1]
```

### 异常,调试和测试

#### *错误处理*
* 可以通过`try...except...finally...`来捕获错误和处理错误(类似于`try...catch...`)
* 所有的错误都继承自`BaseException`,所以再捕获错误的时候,错误的类型如果父类和子类混用,父类会吞掉子类的捕获.
* 上面的捕获错误的机制可以跨越多层调用.
```python
try:
    print('try...')
    r = 10 / int('a')
    print('result:', r)
except ValueError as e:
    print('ValueError:', e)
except ZeroDivisionError as e:
    print('ZeroDivisionError:', e)
finally:
    print('finally...')
print('END')
```

* 常见的错误类型有:
| 类名              |描述                                                         |
| ----------------- | ------------------------------------------------------------ |
| Exception         | 几乎所有的异常都是从它派生而来的                             |
| AttributeError    | 引用 属性或给它赋值失败时触发                                |
| OSError           | 操作系统不能执行指定的任务时引发,有多个子类                  |
| IndexError        | 使用序列中不存在的索引时引发,为LookupError的子类             |
| KeyError          | 使用映射中不存在的键时引发,为LookupError的子类               |
| NameError         | 找不到名称(变量时)引发                                       |
| SytaxError        | 代码不正确时引发                                             |
| TypeError         | 将内置操作或函数用于类型不正确的对象时引发                   |
| ValueError        | 将内置操作或函数用于这样的对象时引发: 其类型正确但包含的值不合适 |
| ZeroDivisionError | 在除法或求模运算的第二个参数为零时触发                       |

#### *调用栈*
*  如果错误没有被捕获,它就会一直往上抛,最后被`Python`解释器捕获,打印一个错误信息,然后程序退出
#### *记录错误*
* 可以通过系统内置的`logging`模块记录错误信息,而且通过配置,可以把错误记录到一个文件里,方便事后排查
```python
import logging

def foo(s):
    return 10 / int(s)

def bar(s):
    return foo(s) * 2

def main():
    try:
        bar('0')
    except Exception as e:
        logging.exception(e)

main()
print('END')
```

#### *抛出错误*
* 抛出错误主要是通过`raise`语句来抛出一个错误的实例,`raise`语句如果不带参数,就会把当前的错误原样抛出.此外,再`except`中`raise`一个`Error`,还可以把一种类型的错误转化成另一种类型
```python
def foo(s):
    n = int(s)
    if n==0:
        raise ValueError('invalid value: %s' % s)
    return 10 / n

def bar():
    try:
        foo('0')
    except ValueError as e:
        print('ValueError!')
        raise

bar()

```

* `warnings.filterwarnings(action, category = Warning,...)`: 用于过滤警告
* `warning.warn(message, category = None)`: 用于发出警告

#### *调试*
* 可以通过`print()` 打印一些数据来进行调试 ,调试完还得删掉
* 断言: `assert`,断言失败会抛出`AssertionError`,和`print`差不多,比较麻烦
* `logging`: 可以指定信息的级别和把输出的信息输出到文件或其他的地方
	* 级别有`debug,info,warning,error`等几个级别

```python
import logging
logging.basicConfig(level=logging.INFO)
s = '0'
n = int(s)
logging.info('n = %d' % n)
print(10 / n)
```

* `pdb`:  启动`Python`的调试器,让程序以单步方式运行,可以随时查看运行的状态
	* 可以通过`python -m pdb file.py`来启动
		* `l`: 可以查看整个代码
		* `n`: 单步执行代码
		* `p variable`: 查看变量
		* `q`: 结束调试
		* `c`: 继续执行
* `pdb.set_trace()`: 需要先引入`pdb`模块,再代码中输入`pdb.set_trace()`,就可以设置一个断点
* 可以通过`IDE`来进行调试

#### *单元测试*
> 单元测试是用来对一个模块、一个函数或者一个类来进行正确性检验的测试工作  
* 为了编写单元测试,我们要引入`python`自带的`unittest`模块.编写单元测试时,我们要编写一个测试类, 从`unittest.TestCase`继承.并且测试类中的方法都必须是以`test`开头,否则不会执行.
	* 测试类中我们要使用很多内置条件判断,我们只需要调用这些方法,就可以断言输出是否使我们期望的,常用的有`assertEqual(),assertTrue()`
	* 另一种断言就是期待抛出制定类型的`Error`
* 运行单元测试: 
	* 可以再测试文件的最后加上: `if __name__ = '__main__:  unittest.main()`,这样就可以把测试文件当成是普通的脚本运行
	* 再命令行通过参数`python -m unittest test.py`直接运行单元测试
* 可以在单元测试中编写俩个特殊的`setup()和tearDown()`方法. 这俩个方法分别在每调用一个测试方法的前后分别执行
```python
class Dict(dict):

    def __init__(self, **kw):
        super().__init__(**kw)

    def __getattr__(self, key):
        try:
            return self[key]
        except KeyError:
            raise AttributeError(r"'Dict' object has no attribute '%s'" % key)

    def __setattr__(self, key, value):
        self[key] = value

import unittest
class TestDict(unittest.TestCase):

    def test_init(self):
        d = Dict(a=1, b='test')
        self.assertEqual(d.a, 1)
        self.assertEqual(d.b, 'test')
        self.assertTrue(isinstance(d, dict))

    def test_key(self):
        d = Dict()
        d['key'] = 'value'
        self.assertEqual(d.key, 'value')

    def test_attr(self):
        d = Dict()
        d.key = 'value'
        self.assertTrue('key' in d)
        self.assertEqual(d['key'], 'value')

    def test_keyerror(self):
        d = Dict()
        with self.assertRaises(KeyError):
            value = d['empty']

    def test_attrerror(self):
        d = Dict()
        with self.assertRaises(AttributeError):
            value = d.empty

>>> python -m unittest TestDict
```

#### *文档测试*
* `python`内置的文档测试`doctest`模块可以直接提取注释中的代码并执行测试
```python
class Dict(dict):
    '''
    Simple dict but also support access as x.y style.

    >>> d1 = Dict()
    >>> d1['x'] = 100
    >>> d1.x
    100
    >>> d1.y = 200
    >>> d1['y']
    200
    >>> d2 = Dict(a=1, b=2, c='3')
    >>> d2.c
    '3'
    >>> d2['empty']
    Traceback (most recent call last):
        ...
    KeyError: 'empty'
    >>> d2.empty
    Traceback (most recent call last):
        ...
    AttributeError: 'Dict' object has no attribute 'empty'
    '''
    def __init__(self, **kw):
        super(Dict, self).__init__(**kw)

    def __getattr__(self, key):
        try:
            return self[key]
        except KeyError:
            raise AttributeError(r"'Dict' object has no attribute '%s'" % key)

    def __setattr__(self, key, value):
        self[key] = value

if __name__=='__main__':
    import doctest
    doctest.testmod()
```


### IO编程
> `IO`再计算机中指`input/output`,也就是输入和输出.`IO`又分为同步和异步`IO`  
#### 文件读写
* 读取文件:  只需要打开一个文件对象, 使用`python`内置的`open(filepath, symbol)`,如果文件不存在,就会报错
	* `symbol`为`r`的时候是读取
	* 如果文件打开成功, 调用`read()`方法可以一次读取文件的全部内容,`pythion`把内容读取到内存中,用一个`str`对象表示
	* 最后一步调用`close()`方法关闭文件.文件使用完必须关闭,因为文件会占用操作系统的资源,并且操作系统同一时间打开的文件数量也是有限的
* 由于读写文件有可能产生`IOError`,一旦出错,后面的`f.close()`就不会调用,因此我们可以用`try...finally`来实现.最好还是使用系统的`with`语句

```python
with open('/path/to/file','r') as f:
	print(f.read())
```

* `read()`方法是一次性读取,会引起性能的问题,保险起见可以反复的调用`read(size)`,每次最多读取`size`个字节.另外调用`readline()`可以每次读取一行内容,调用`readlines()`一次性读取所有内容并按行返回`list`.
	* 文件较小的时候,`read()`一次性读取比较方便
	* 如过不确定文件大小,反复调用`read(size)`比较保险,如过是配置文件,调用`readlines()`比较方便
* file-like object: 像`open()`函数返回的这种有个`read()`方法的对象,再`python`中统称为`file-like Object`
* 要读取二进制文件时,可以把`symbol`改为`rb`
* 字符编码: 要读取非`UTF-8`编码的文件,需要给`open()`函数传入`encoding`参数
	* 遇到编码不规范的文件,可能会遇到`UnicodeDecodeError`,遇到这种情况,`open()`函数还接受一个`errors`参数.表示如果遇到编码错误后如何处理,最简单的方式是直接忽略

```python
f = open('/Users/michael/gbk.txt', 'r', encoding='gbk')
f.read()
# '测试'

f = open('/Users/michael/gbk.txt', 'r', encoding='gbk', errors='ignore')
```

* 写文件:  和读文件差不多,只是把`symbol`替换成`w或者 wb`,表示写文本文件或者写二进制文件
	* 你可以反复调用`write()`来写入文件，但是务必要调用`f.close()`来关闭文件。当我们写文件时，操作系统往往不会立刻把数据写入磁盘，而是放到内存缓存起来，空闲的时候再慢慢写入。只有调用`close()`方法时，操作系统才保证把没有写入的数据全部写入磁盘。忘记调用`close()`的后果是数据可能只写了一部分到磁盘，剩下的丢失了。所以，还是用`with`语句来得保险
	* 编写特定编码的文件,可以传入对应的`encoding`参数
	* `w`模式写入文件时,如果文件已存在,会直接覆盖,如果我们在文件末尾追加,可以传入`a`

#### **StringIO和 BytesIO**

> 这俩个模块都是在内存中进行读写  
* StringIO: 在内存中读写`str`
	* `getvalue()`: 方法用于获得写入后的`str`
	* 要读取`StringIO`,可以用一个`str`初始化`StringIO`,然后,像读文件一样读取
	
```python
from io import StringIO
f = StringIO()
f.write('hello')
# 5
f.write(' ')
# 1
f.write('world!')
# 6
print(f.getvalue())
# hello world!

from io import StringIO
f = StringIO('Hello!\nHi!\nGoodbye!')
while True:
   s = f.readline()
   if s == '':
      break
    print(s.strip())
# Hello!
# Hi!
# Goodbye!
```

* BytesIO:  再内存中读写二进制数据

```python
from io import BytesIO
f = BytesIO()
f.write('中文'.encode('utf-8'))
# 6
print(f.getvalue())
# b'\xe4\xb8\xad\xe6\x96\x87'

# 二进制的读写和StringIO类似
from io import BytesIO
f = BytesIO(b'\xe4\xb8\xad\xe6\x96\x87')
f.read()
# b'\xe4\xb8\xad\xe6\x96\x87'
```


#### **操作文件和目录**

> 主要使用的是`os`模块  
* `os.name` : 操作系统类型
* `os.uname`: 详细的系统信息
* `os.environ`: 获取在操作系统中定义的环境变量,如果要获取某一个环境变量的值.要调用`os.environ.get('key',default)`
* 操作文件和目录: 一部分放在`os`模块中,一部分放在`os.path`模块中
	* `os.path.abspath(file)`: 获取指定文件的绝对路径,  参数`.`是获取当前目录的绝对路径
	* `os.path.relpath(file)`: 获取指定文件相对路径
	* `os.path.join(rootpath, filename)`: 再某一个目录下创建新目录, 首先新目录的完整路径表示出来
	* `os.mkdir(filepath)`: 创建一个目录
	* `os.rmdir(filepath')`: 删掉一个目录
	* `os.path.split(filepath)`: 把一个路径拆分成俩部分,后一部分总是最后级别的目录或者文件名
	* `os.path.splitext(filepath)`: 获取文件的扩展名
	* `os.listdir(str)`: 获取指定目录下的文件(一级), `str`为`.`时,获取当前的目录
		* 这些合并、拆分路径的函数并不要求目录和文件要真实存在，它们只对字符串进行操作。
	* `os.path.isdir(filename)`: 判断一个字符串是否是目录
	* `os.path.isfile(filename)`: 判断一个字符串是否是文件
	

```python

#能在当前目录以及当前目录的所有子目录下查找文件名包含指定字符串的文件，并打印出相对路径。
import os

def findAssignFile(str, path = '.'):
  list = []
  for x in os.listdir(path):
    if os.path.isdir(x):
      findAssignFile(str,x)
    else:
      if os.path.split(x)[1].find(str) >= 0:
        list.append(os.path.relpath(x)) 
  return list
```

#### 序列化
> 把变量从内存中变成可存储或传输的过程称之为序列化,再`Python`中叫`picking`,可以把序列化后的内容写入磁盘,或者通过网络传输到别的机器上.反过来,称之为反序列化`unpicking`  

* `pickle.dumps(obj)`: 把任意对象序列化成一个`bytes`,就可以把`bytes`直接写入文件了
* `pickle.dump(obj,f)`: 把对象序列化后直接写入一个`file-like Object`
* `pickle.loads(bytes)`: 把从磁盘读到的内容直接反序列化出对象
* `pickle.load(f)`: 直接从一个`file-like Object`中直接反序列化出对象

```python
import pickle
d = dict(name='wyt',age=18)

f = open('test.txt','wb')
pickle.dump(d, f)
f.close()

wf = open('test.txt','rb')
d1 = pickle.load(wf)
wf.close()

print(d1)
```

####  ** json**

> `python`模块能够把`python`对象转化成`json`对象  

* `json.dumps(obj)`:  返回一个标准的`json`
* `json.dump(obj,f)`: 把转化后的`json`写入一个`file-like Object`
* `json.loads(json)`: 把一个`json`对象反序列化成`python`对象
* `json.load(f)`:  把一个`file-like Object`反序列化成`python`对象
* `json.dumps(dict, default=instance2json)`: 可以传入一个函数,把一个类的实例转换成`json`
	* `json.dumps(indtance, default=lambda o:o.__dict__)`:如果定义了`__slots`,这种方法不好使,要自己编写函数
* `json.loads(json_str, object_hook=dict2class)`: 在反序列化的时候可以传入一个转换函数,把`dict`转换成类的实例

```python
import json
class Student(object):
  def __init__(self,name='11',age=22):
    self.name = name
    self.age = age

s = Student('wyt',18)
f = open('dump.js','w')
json.dump(s,f,default=lambda x:x.__dict__)
f.close()

def dict2Class(c):
  return lambda o:c(**o)
f1 = open('dump.js','r')
d = json.load(f1,object_hook=dict2Class(Student))
f1.close()

print(d)
```

### **进程和线程**

> 线程是最小的执行单元,每个进程至少有一个线程.如何调度进程和线程,完全有操作系统决定,程序是不能决定什么时候执行,执行多长时间,多进程和多线程的程序涉及到同步,数据共享的问题. `python`即支持多进程,又支持多线程  

#### **多进程**
* `Mac`系统下有`fork()`特殊函数调用,调用一次,执行俩次,在父进程和子进程都执行一次,父进程执行返回子进程的`id`,子进程执行返回数字`0`
	* `os.getpid()`: 获取当前进程的`id`
	* `os.getppid()`: 获取当前进程父进程的`id`
```python
import os

print('Process (%s) start...' % os.getpid())
# Only works on Unix/Linux/Mac:
pid = os.fork()
if pid == 0:
    print('I am child process (%s) and my parent is %s.' % (os.getpid(), os.getppid()))
else:
    print('I (%s) just created a child process (%s).' % (os.getpid(), pid))
```

* `multiprocessing`模块是跨平台版本的多进程模块. 该模块中的`Process`类来代表一个进程对象
	* `p = Process(target=fn, args=(val1,val2…)): 返回一个Process 实例`
		* `target`: 子进程要执行的代码
		* `args`: 传给子进程的参数
	* `p.start()`:  启动子进程
	* `p.join()`: 等待子进程结束后再继续执行下去,通常用于进程间的同步
```python
from multiprocessing import Process
import os

# 子进程要执行的代码
def run_proc(name):
    print('Run child process %s (%s)...' % (name, os.getpid()))

if __name__=='__main__':
    print('Parent process %s.' % os.getpid())
    p = Process(target=run_proc, args=('test',))
    print('Child process will start.')
    p.start()
    p.join()
    print('Child process end.')
```

* `Pool`进程池,用于批量的创建子进程,启动大量的子进程

```python
from multiprocessing import Pool
import os, time, random

def long_time_task(name):
    print('Run task %s (%s)...' % (name, os.getpid()))
    start = time.time()
    time.sleep(random.random() * 3)
    end = time.time()
    print('Task %s runs %0.2f seconds.' % (name, (end - start)))

if __name__=='__main__':
    print('Parent process %s.' % os.getpid())
    p = Pool(4)
    for i in range(5):
        p.apply_async(long_time_task, args=(i,))
    print('Waiting for all subprocesses done...')
    p.close() # 调用该方法后,不能再添加新的进程
    p.join() # 等待所有子进程执行完毕
    print('All subprocesses done.')

# Pool的默认大小是cpu的核数,超出cpu的核数需要等待
```

* 子进程

> `subprocess`模块可以启动一个子进程,控制其输入和输出  

* 进程间通信

> `Python`的`multiprocessing`模块包装了底层的机制,提供了`Queue,Pipes`等多种方式来交换数据  

```python
call(['nslookup', 'www.python.org'])
print('Exit code:', r)
运行结果：

$ nslookup www.python.org
Server:        192.168.19.4
Address:    192.168.19.4#53

Non-authoritative answer:
www.python.org    canonical name = python.map.fastly.net.
Name:    python.map.fastly.net
Address: 199.27.79.223

Exit code: 0
如果子进程还需要输入，则可以通过communicate()方法输入：

import subprocess

print('$ nslookup')
p = subprocess.Popen(['nslookup'], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
output, err = p.communicate(b'set q=mx\npython.org\nexit\n')
print(output.decode('utf-8'))
print('Exit code:', p.returncode)
上面的代码相当于在命令行执行命令nslookup，然后手动输入：

set q=mx
python.org
exit
运行结果如下：

$ nslookup
Server:        192.168.19.4
Address:    192.168.19.4#53

Non-authoritative answer:
python.org    mail exchanger = 50 mail.python.org.

Authoritative answers can be found from:
mail.python.org    internet address = 82.94.164.166
mail.python.org    has AAAA address 2001:888:2000:d::a6


Exit code: 0

# 进程间通信
#Process之间肯定是需要通信的，操作系统提供了很多机制来实现进程间的通信。#Python的multiprocessing模块包装了底层的机制，提供了Queue、Pipes等多# 种方式来交换数据。

# 我们以Queue为例，在父进程中创建两个子进程，一个往Queue里写数据，一个从Queue里读数据：

from multiprocessing import Process, Queue
import os, time, random

# 写数据进程执行的代码:
def write(q):
    print('Process to write: %s' % os.getpid())
    for value in ['A', 'B', 'C']:
        print('Put %s to queue...' % value)
        q.put(value)
        time.sleep(random.random())

# 读数据进程执行的代码:
def read(q):
    print('Process to read: %s' % os.getpid())
    while True:
        value = q.get(True)
        print('Get %s from queue.' % value)

if __name__=='__main__':
    # 父进程创建Queue，并传给各个子进程：
    q = Queue()
    pw = Process(target=write, args=(q,))
    pr = Process(target=read, args=(q,))
    # 启动子进程pw，写入:
    pw.start()
    # 启动子进程pr，读取:
    pr.start()
    # 等待pw结束:
    pw.join()
    # pr进程里是死循环，无法等待其结束，只能强行终止:
    pr.terminate()

```

* 父进程所有`Python`对象都必须通过`pickle`序列化再传到子进程中去
#### **多线程**
* `Python`提供了俩个模块: `_thread和threading`,前者是低级模块,后者是高级模块. 绝大多数只需要使用`threading`模块就可以了
	* `threading`模块中的`curent_thread()`可以获取到当前线程的实例
	* `threading.Thread(target=fn, args=(arg1,...),propertyA=propertyAValue...)`: 可以创建一个线程的实例
	* 主线程实例的名字为`MainThread`, 如果不给子线程指定名字,系统会自动取名字,`Thread-1,Thread-2...`
* 多线程和多进程的区别在于,多进程中,同一个变量各自有一份拷贝再每个进程中,互不影响. 而多线程中,所有变量都有所有线程共享.可能会造成修改上的冲突.可以给一个线程上把锁.来保证程序的执行,不受外界的干扰.但是锁只有一个
	* `lock = threading.Lock()`:  创建一个锁
	* `lock.acquire()`: 获取一把锁
	* `lock.release()`: 释放锁,一定要释放,不然其它等待锁的线程将永远等待下去,成为死线程
#### **ThreadLocal**
* 可以为每个线程提供自己读写的独立副本,互不干扰. 主要解决了参数在多个线程中函数传递的问题

```python
import threading

local_school = threading.local()

def print_std(sex):
    std = local_school.std
    print('current student {} is {}'.format(sex,std))

def process_std(sex):
    local_school.std = threading.current_thread().name
    print_std(sex)

if __name__ == '__main__':
    s1 = threading.Thread(target=process_std, args=('male',), name='WYT')
    s2 = threading.Thread(target=process_std, args=('fale',), name='lfl')

    s1.start()
    s2.start()
    s1.join()
    s2.join()

```

#### **多线程和多进程优缺点**
* 多进程: 稳定性高, 一个子进程蹦了,不影响主进程和其它子进程
* 多线程: 比多进程快些, 任何一个线程挂掉都可能直接造成整个进程崩溃
* 计算密集性: 要进行大量的计算, 消耗`cpu`资源, 代码运行效率至关重要,` c`语言比较好些 
* io密集性:   涉及到网络,磁盘`IO`的任务都属于该类型, 特点是`cpu`消耗很少, 脚本语言较优
#### 分布式进程 (暂时跳过)




#mydiary/python/basic